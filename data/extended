#!/bin/tcsh
#+
# Reduce extended data
#

source $SMURF_DIR/smurf.csh > /dev/null
source $CONVERT_DIR/convert.csh > /dev/null
source $KAPPA_DIR/kappa.csh > /dev/null
source $HDSTOOLS_DIR/hdstools.csh > /dev/null

setenv ADAM_USER "adam_extended"

# map of extended stuff from early last year - M17
set obsdate = 20110531
set obsnum = 00011
set lambda = 's8?'
set allsub = (s8a s8b s8c s8d)
set basename = "$lambda"$obsdate\_$obsnum

set dataroot = /scuba2
#set msg = quiet
set msg = verbose
#set msg = normal

set onlyone = 1
#goto map_bright_extended
#goto map_default
#goto respmap
goto jk


map_default:

echo "*** Reduce M17 map using default reduction ***"

makemap $dataroot/"$lambda"/$obsdate/$obsnum/"$basename"\_"*" \
    m17_default method=iterate \
    config='"^$STARLINK_DIR/share/smurf/dimmconfig.lis,itermap=0,chitol=<undef>,maptol=0.05,numiter=-200,shortmap=-1"' \
    msg_filter=$msg

foreach iter ( 02 03 10 30 )
    ndf2fits m17_default.more.smurf.itermaps.ch00i0$iter m17_default_$iter.fits
end

if ( $onlyone == 1 ) goto finish





map_bright_extended:

echo "*** Reduce M17 map using bright_extended reduction ***"


makemap $dataroot/"$lambda"/$obsdate/$obsnum/"$basename"\_"*" \
    m17_bright_extended method=iterate \
    config='"^$STARLINK_DIR/share/smurf/dimmconfig_bright_extended.lis,itermap=1,numiter=-200,shortmap=-1"' \
    msg_filter=$msg

makemap $dataroot/"$lambda"/$obsdate/$obsnum/"$basename"\_"*" \
    m17_bright_extended_2 method=iterate \
    config='"^$STARLINK_DIR/share/smurf/dimmconfig_bright_extended.lis,numiter=2"' \
    msg_filter=$msg

ndf2fits m17_bright_extended.sdf m17_bright_extended.fits
ndf2fits m17_bright_extended_2.sdf m17_bright_extended_2.fits

if ( $onlyone == 1 ) goto finish






respmap:

foreach sub ( $allsub )
    calcflat $dataroot/$sub/$obsdate/$obsnum/$sub$obsdate\_$obsnum\_0002 \
        flat_$sub resp=resp_$sub accept

    smurfcopy $dataroot/$sub/$obsdate/$obsnum/$sub$obsdate\_$obsnum\_0003 \
        slice_$sub 1

    hcopy resp_$sub.data_array slice_$sub.data_array
end

wcsmosaic slice_s8\* ref=! out=m17_resp_fplane method=nearest accept
wcsalign m17_resp_fplane out=m17_resp_fplane_align method=nearest \
    ref=m17_default accept
ndf2fits m17_resp_fplane_align \!m17_resp_fplane_align.fits

if ( $onlyone == 1 ) goto finish









jk:

echo "*** Jackknife maps of default and bright_extended reductions ***"


foreach srcmap ( m17_default m17_bright_extended )
    # mosaics of even and odd halves
    @ nchunks = `hdir $srcmap.more.smurf.shortmaps | grep CH00SH | wc -l`

    @ nhalf = $nchunks / 2

    set index = 0

    echo "" > chunks_even.lis
    echo "" > chunks_odd.lis

    while ($index < $nhalf)
        @ chunk_even = $index * 2
        @ chunk_odd = $chunk_even + 1

        set evenstr = `awk 'BEGIN { printf "%06i\n", '$chunk_even' }'`
        set oddstr = `awk 'BEGIN { printf "%06i\n", '$chunk_odd' }'`

        echo $srcmap.more.smurf.shortmaps.ch00sh$evenstr >> chunks_even.lis
        echo $srcmap.more.smurf.shortmaps.ch00sh$oddstr >> chunks_odd.lis

        @ index++
    end

    ndfcopy $srcmap map_ref trim trimwcs

    wcsmosaic ^chunks_even.lis ref=map_ref out=$srcmap\_even method=nearest \
        variance accept

    wcsmosaic ^chunks_odd.lis ref=map_ref out=$srcmap\_odd method=nearest \
        variance accept

    rm map_ref.sdf


    # take the difference to estimate map of pure noise, and then
    # measure angular power spectrum

    sub $srcmap\_even $srcmap\_odd $srcmap\_jk

    ndf2fits $srcmap\_jackknife \!$srcmap\_jk.fits > /dev/null




end


if ( $onlyone == 1 ) goto finish




finish:
